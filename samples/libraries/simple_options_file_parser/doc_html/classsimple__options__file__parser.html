<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simple_options_file_parser (version 1.0.01)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <table cellspacing="0" cellpadding="0">
    <tbody>
      <tr style="height: 56px;">
        <td id="projectlogo" style="padding-bottom: 8px; padding-top: 8px;padding-left: 10px;"><img alt="Tools supported by the simple_options_file_parser library" src="HTML_icon.png"/></td>
		<td id="projectlogospacing" style="padding-bottom: 8px; padding-left: 10px;"></td>
        <td id="projectalign" style="font-size: x-small">
          <div id="projectname">  simple_options_file_parser version 1.0.01</span>
          </div>
        </td>
      </tr>
    </tbody>
  </table>
</div>
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classsimple__options__file__parser.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsimple__options__file__parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simple_options_file_parser Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Simple parser for label / value option files.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="simple__options__file__parser_8hpp_source.html">simple_options_file_parser.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad399a2ebe5c80b984dffd03f28a37c8" id="r_aad399a2ebe5c80b984dffd03f28a37c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad399a2ebe5c80b984dffd03f28a37c8">get_option_double</a> (const string &amp;option_label, double &amp;option_value)</td></tr>
<tr class="memdesc:aad399a2ebe5c80b984dffd03f28a37c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a label as a double value.  <br /></td></tr>
<tr class="separator:aad399a2ebe5c80b984dffd03f28a37c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e6ce7d5a3ef8ccf0491cf9efb841e3" id="r_a93e6ce7d5a3ef8ccf0491cf9efb841e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e6ce7d5a3ef8ccf0491cf9efb841e3">get_option_double_array</a> (const string &amp;option_label, vector&lt; double &gt; &amp;option_value)</td></tr>
<tr class="memdesc:a93e6ce7d5a3ef8ccf0491cf9efb841e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a label as a list of double values.  <br /></td></tr>
<tr class="separator:a93e6ce7d5a3ef8ccf0491cf9efb841e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae02e51a90c49aa774d7617553ded74c" id="r_aae02e51a90c49aa774d7617553ded74c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae02e51a90c49aa774d7617553ded74c">get_option_int</a> (const string &amp;option_label, int &amp;option_value)</td></tr>
<tr class="memdesc:aae02e51a90c49aa774d7617553ded74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a label as an int value.  <br /></td></tr>
<tr class="separator:aae02e51a90c49aa774d7617553ded74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad30998106a9449134f81f148288dff3" id="r_aad30998106a9449134f81f148288dff3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad30998106a9449134f81f148288dff3">get_option_int_array</a> (const string &amp;option_label, vector&lt; int &gt; &amp;option_value)</td></tr>
<tr class="memdesc:aad30998106a9449134f81f148288dff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a label as a list of int values.  <br /></td></tr>
<tr class="separator:aad30998106a9449134f81f148288dff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f54f56004c6740e1a488b4cbaec33" id="r_a794f54f56004c6740e1a488b4cbaec33"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a794f54f56004c6740e1a488b4cbaec33">get_option_string</a> (const string &amp;option_label, string &amp;option_value)</td></tr>
<tr class="memdesc:a794f54f56004c6740e1a488b4cbaec33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a label as a string.  <br /></td></tr>
<tr class="separator:a794f54f56004c6740e1a488b4cbaec33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440cba9edccec2aef9070e810fbf362c" id="r_a440cba9edccec2aef9070e810fbf362c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a440cba9edccec2aef9070e810fbf362c">get_option_string_array</a> (const string &amp;option_label, vector&lt; string &gt; &amp;option_value)</td></tr>
<tr class="memdesc:a440cba9edccec2aef9070e810fbf362c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the words in a string as separate elements.  <br /></td></tr>
<tr class="separator:a440cba9edccec2aef9070e810fbf362c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47652d914b7f1c92c576ffd61c436507" id="r_a47652d914b7f1c92c576ffd61c436507"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47652d914b7f1c92c576ffd61c436507">parse</a> (const string &amp;options_file, int &amp;error_line)</td></tr>
<tr class="memdesc:a47652d914b7f1c92c576ffd61c436507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and interpret a simple options file.  <br /></td></tr>
<tr class="separator:a47652d914b7f1c92c576ffd61c436507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52644b5d7c71110cd7e2bd8d887ba10f" id="r_a52644b5d7c71110cd7e2bd8d887ba10f"><td class="memItemLeft" align="right" valign="top"><a id="a52644b5d7c71110cd7e2bd8d887ba10f" name="a52644b5d7c71110cd7e2bd8d887ba10f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>simple_options_file_parser</b> (void)</td></tr>
<tr class="memdesc:a52644b5d7c71110cd7e2bd8d887ba10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a52644b5d7c71110cd7e2bd8d887ba10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97aaa161998c7b191fda1253397c5e3" id="r_ab97aaa161998c7b191fda1253397c5e3"><td class="memItemLeft" align="right" valign="top"><a id="ab97aaa161998c7b191fda1253397c5e3" name="ab97aaa161998c7b191fda1253397c5e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~simple_options_file_parser</b> (void)</td></tr>
<tr class="memdesc:ab97aaa161998c7b191fda1253397c5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab97aaa161998c7b191fda1253397c5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a71ca3edf8e07c4b4dbde919ecb1df598" id="r_a71ca3edf8e07c4b4dbde919ecb1df598"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71ca3edf8e07c4b4dbde919ecb1df598">read_data_line</a> (ifstream &amp;file, string &amp;line, int &amp;last_line_read, int &amp;line_data)</td></tr>
<tr class="memdesc:a71ca3edf8e07c4b4dbde919ecb1df598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next line with actual data to process.  <br /></td></tr>
<tr class="separator:a71ca3edf8e07c4b4dbde919ecb1df598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ce882147b8f006e2084cae95d628d3" id="r_ae6ce882147b8f006e2084cae95d628d3"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6ce882147b8f006e2084cae95d628d3">reduce</a> (const string &amp;str, const string &amp;fill=&quot; &quot;, const string &amp;whitespace=&quot; \t&quot;)</td></tr>
<tr class="memdesc:ae6ce882147b8f006e2084cae95d628d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes leading and trailing whitespace from a string. Moreover, internal whitespace is purged (leaving a single occurence between non-whitespace characters) and replaced by some string selectable by the user.  <br /></td></tr>
<tr class="separator:ae6ce882147b8f006e2084cae95d628d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da64a4438d81719c9fc78a4cd5697ad" id="r_a2da64a4438d81719c9fc78a4cd5697ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2da64a4438d81719c9fc78a4cd5697ad">split</a> (const string &amp;txt, vector&lt; std::string &gt; &amp;strs, char ch=' ')</td></tr>
<tr class="memdesc:a2da64a4438d81719c9fc78a4cd5697ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string at the points specified by some configurable character.  <br /></td></tr>
<tr class="separator:a2da64a4438d81719c9fc78a4cd5697ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27e505309ad87ef5d97ff72b5902218" id="r_af27e505309ad87ef5d97ff72b5902218"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af27e505309ad87ef5d97ff72b5902218">trim</a> (const string &amp;str, const string &amp;whitespace=&quot; \t&quot;)</td></tr>
<tr class="memdesc:af27e505309ad87ef5d97ff72b5902218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading and trailing whitespace from a string. It is possible to define what is "whitespace".  <br /></td></tr>
<tr class="separator:af27e505309ad87ef5d97ff72b5902218"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4aae2397ebf1f880628e84519028703d" id="r_a4aae2397ebf1f880628e84519028703d"><td class="memItemLeft" align="right" valign="top"><a id="a4aae2397ebf1f880628e84519028703d" name="a4aae2397ebf1f880628e84519028703d"></a>
map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>options_</b></td></tr>
<tr class="memdesc:a4aae2397ebf1f880628e84519028703d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map holding the label / value pairs loaded from the input file. <br /></td></tr>
<tr class="separator:a4aae2397ebf1f880628e84519028703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple parser for label / value option files. </p>
<p>This class implements a very simple option files parser.</p>
<p>These option files must be text files. Values are input by means of unique labels. The specific format to write a label and its corresponding value is:</p>
<p>label = value</p>
<p>All the elements in the previous example (label, equal sign, value) must be written in the same line.</p>
<p>Multiple labels must be written in consecutive lines. For instance:</p>
<p>label1 = value1 label2 = value2</p>
<p>Values may be of type string, integer or double. Additionally, list of integers and doubles are allowed. These lists must separate the different integer o double values by means of spaces. For instance:</p>
<p>my_integer_list = 1 2 3 4 my_double_list = 1.2 3.4 5.6 7.8 9.0</p>
<p>When the values are strings, the leading a trailing spaces are removed. Internal whitespace, whowever is fully preserved. Therefore, in the following example:</p>
<p>my_string_value = this is a test</p>
<p>the actual value processed by this class would be "this is    a   test". Note how the leading and trailing spaces have been removed, but the internal whitespace has not.</p>
<p>Labels are case sensitive. Therefore, label "my_value" is not equal to "MY_VALUE" nor to "mY_vAlUe".</p>
<p>Blank lines are ignored. It is possible to write comments; lines whose first character is "#" will be considered as comments. For example:</p>
<p># This is a comment.</p>
<p>To use this class,</p>
<ul>
<li>Declare / instantiate a <a class="el" href="classsimple__options__file__parser.html" title="Simple parser for label / value option files.">simple_options_file_parser</a> object.</li>
<li>Call method <a class="el" href="#a47652d914b7f1c92c576ffd61c436507" title="Load and interpret a simple options file.">parse()</a> to load the options file into memory.</li>
<li>Call the different get_xxx_xxx() methods to retrieve the value of the labels of interest, using the proper type (int, double, string, int_array or double_array) for the kind of value expected. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aad399a2ebe5c80b984dffd03f28a37c8" name="aad399a2ebe5c80b984dffd03f28a37c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad399a2ebe5c80b984dffd03f28a37c8">&#9670;&#160;</a></span>get_option_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::get_option_double </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a label as a double value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_label</td><td>The label identifying the option sought. </td></tr>
    <tr><td class="paramname">option_value</td><td>The value sought. It is only meaningful when the method finishes correctly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: Label not found. The label in "option_label" does not exist in the options file.</li>
<li>2: The value related to the label can not be interpreted as a double value.</li>
</ul>
</dd></dl>
<p>This method tries to convert the string representing the value to double format. If such string is not a double, an error code will be returned.</p>
<p>Moreover, an error code is also returned if the label sought is not found. In this case, it is important to remember that labels are case sensitive. </p>

</div>
</div>
<a id="a93e6ce7d5a3ef8ccf0491cf9efb841e3" name="a93e6ce7d5a3ef8ccf0491cf9efb841e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e6ce7d5a3ef8ccf0491cf9efb841e3">&#9670;&#160;</a></span>get_option_double_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::get_option_double_array </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a label as a list of double values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_label</td><td>The label identifying the option sought. </td></tr>
    <tr><td class="paramname">option_value</td><td>The array of values sought. It is only meaningful when the method finishes correctly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: Label not found. The label in "option_label" does not exist in the options file.</li>
<li>2: One or more values in the expected list of doubles can not be interpreted as a double value.</li>
</ul>
</dd></dl>
<p>This method tries to convert the string representing a list of double values separated by spaces to its array of doubles equivalent. If one or more of the components in the string cannot be interpreted as a double value, an error code will be returned. On the contrary, when such conversion works, the output option_value array will contain as many values as doubles found in the list. The number of values may be obtained by calling method size() of option_value.</p>
<p>Moreover, an error code is also returned if the label sought is not found. In this case, it is important to remember that labels are case sensitive. </p>

</div>
</div>
<a id="aae02e51a90c49aa774d7617553ded74c" name="aae02e51a90c49aa774d7617553ded74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae02e51a90c49aa774d7617553ded74c">&#9670;&#160;</a></span>get_option_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::get_option_int </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a label as an int value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_label</td><td>The label identifying the option sought. </td></tr>
    <tr><td class="paramname">option_value</td><td>The value sought. It is only meaningful when the method finishes correctly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: Label not found. The label in "option_label" does not exist in the options file.</li>
<li>2: The value related to the label can not be interpreted as an int value.</li>
</ul>
</dd></dl>
<p>This method tries to convert the string representing the value to int format. If such string is not an int, an error code will be returned.</p>
<p>Moreover, an error code is also returned if the label sought is not found. In this case, it is important to remember that labels are case sensitive. </p>

</div>
</div>
<a id="aad30998106a9449134f81f148288dff3" name="aad30998106a9449134f81f148288dff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad30998106a9449134f81f148288dff3">&#9670;&#160;</a></span>get_option_int_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::get_option_int_array </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a label as a list of int values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_label</td><td>The label identifying the option sought. </td></tr>
    <tr><td class="paramname">option_value</td><td>The array of values sought. It is only meaningful when the method finishes correctly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: Label not found. The label in "option_label" does not exist in the options file.</li>
<li>2: One or more values in the expected list of int can not be interpreted as an int value.</li>
</ul>
</dd></dl>
<p>This method tries to convert the string representing a list of int values separated by spaces to its array of int equivalent. If one or more of the components in the string cannot be interpreted as an int value, an error code will be returned. On the contrary, when such conversion works, the output option_value array will contain as many values as int found in the list. The number of values may be obtained by calling method size() of option_value.</p>
<p>Moreover, an error code is also returned if the label sought is not found. In this case, it is important to remember that labels are case sensitive. </p>

</div>
</div>
<a id="a794f54f56004c6740e1a488b4cbaec33" name="a794f54f56004c6740e1a488b4cbaec33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794f54f56004c6740e1a488b4cbaec33">&#9670;&#160;</a></span>get_option_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::get_option_string </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a label as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_label</td><td>The label identifying the option sought. </td></tr>
    <tr><td class="paramname">option_value</td><td>The value sought. It is only meaningful when the method finishes correctly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: Label not found. The label in "option_label" does not exist in the options file.</li>
</ul>
</dd></dl>
<p>This method never tries to convert the text value in the options file, so no errors must be expected on this side.</p>
<p>However, an error code is also returned if the label sought is not found. In this case, it is important to remember that labels are case sensitive. </p>

</div>
</div>
<a id="a440cba9edccec2aef9070e810fbf362c" name="a440cba9edccec2aef9070e810fbf362c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440cba9edccec2aef9070e810fbf362c">&#9670;&#160;</a></span>get_option_string_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::get_option_string_array </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the words in a string as separate elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_label</td><td>The label identifying the option sought. </td></tr>
    <tr><td class="paramname">option_value</td><td>The array of values sought. It is only meaningful when the method finishes correctly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: Label not found. The label in "option_label" does not exist in the options file.</li>
</ul>
</dd></dl>
<p>This method splits all the words in a string into a list of strings. That is, the string "This is a string" is returned as the list of separate values "This", "is", "a" and "string". Leading and trailing Whitespace, as well as that found between words is completely removed.</p>
<p>An error code is returned if the label sought is not found. In this case, it is important to remember that labels are case sensitive. </p>

</div>
</div>
<a id="a47652d914b7f1c92c576ffd61c436507" name="a47652d914b7f1c92c576ffd61c436507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47652d914b7f1c92c576ffd61c436507">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>options_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>error_line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and interpret a simple options file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options_file</td><td>The name of the file containing the options to load. </td></tr>
    <tr><td class="paramname">error_line</td><td>If an error is detected while loading the options file, this parameter will contain the line number where the aforementioned error was detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code:<ul>
<li>0: Successful completion.</li>
<li>1: The name of the options file is empty (parameter options_file; no error line is set).</li>
<li>2: Error opening the input options file (no error line is set).</li>
<li>3: Missing equal sign ("=") when parsing a label / value pair.</li>
<li>4: Empty label or value found while parsing a label / value pair. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a71ca3edf8e07c4b4dbde919ecb1df598" name="a71ca3edf8e07c4b4dbde919ecb1df598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ca3edf8e07c4b4dbde919ecb1df598">&#9670;&#160;</a></span>read_data_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool simple_options_file_parser::read_data_line </td>
          <td>(</td>
          <td class="paramtype">ifstream &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>last_line_read</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>line_data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the next line with actual data to process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file to read the lines from. </td></tr>
    <tr><td class="paramname">line</td><td>The line of data retrieved. </td></tr>
    <tr><td class="paramname">last_line_read</td><td>Number of the last line read. </td></tr>
    <tr><td class="paramname">line_data</td><td>Number of the line where a line of data starts (may differ from line_read if comments are found). Used to report the line when syntax errors are detected when processing a label / value pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a new line has been retrieved, false if the end-of-file condition is arised.</dd></dl>
<p>This methods reads complete lines from the input file, skipping those that begin with a comment sign (#).</p>
<p>Normally, data lines (those that contain an statement label = value) take only that line, but in the case of lists of values (as in label = value1 value2 ... valueN) these may become too long so lines are split using the backslash character.</p>
<p>When such event occurs, lines are read consecutively until no backslash is found. The set of lines read is then merged into a single one removing the backlashes, as if it would have been written as a single line in the original input file. </p>

</div>
</div>
<a id="ae6ce882147b8f006e2084cae95d628d3" name="ae6ce882147b8f006e2084cae95d628d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ce882147b8f006e2084cae95d628d3">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string simple_options_file_parser::reduce </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>fill</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>whitespace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;\t&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes leading and trailing whitespace from a string. Moreover, internal whitespace is purged (leaving a single occurence between non-whitespace characters) and replaced by some string selectable by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string whose whitespace has to be removed, purged and replaced. </td></tr>
    <tr><td class="paramname">fill</td><td>The string to use to replace the internal whitespace once it's been purged. </td></tr>
    <tr><td class="paramname">whitespace</td><td>Set of characters to be considered as whitespace.</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: assuming that str is set to "   abc d   e  f   ", calling this method like this:</p>
<p>reduce(str, " ", " \t")</p>
<p>would yield this result: str = "abc d e f". This is the "normal" whay to use this method.</p>
<p>However, calling the method like this:</p>
<p>reduce(str, "***", " \t")</p>
<p>would make str look like this: "abc***d***e***f" </p>

</div>
</div>
<a id="a2da64a4438d81719c9fc78a4cd5697ad" name="a2da64a4438d81719c9fc78a4cd5697ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da64a4438d81719c9fc78a4cd5697ad">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int simple_options_file_parser::split </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>txt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>strs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a string at the points specified by some configurable character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txt</td><td>The string to be split. </td></tr>
    <tr><td class="paramname">strs</td><td>A vector of strings, containing the tokens resulting from the splitting process. </td></tr>
    <tr><td class="paramname">ch</td><td>The character used as delimiter to find the places where the input string has to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in output vector strs (that is, the number of tokens resulting from the splitting process). May be zero. </dd></dl>

</div>
</div>
<a id="af27e505309ad87ef5d97ff72b5902218" name="af27e505309ad87ef5d97ff72b5902218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27e505309ad87ef5d97ff72b5902218">&#9670;&#160;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string simple_options_file_parser::trim </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>whitespace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;\t&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove leading and trailing whitespace from a string. It is possible to define what is "whitespace". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string whose leading and trailing whitespace has to be removed. </td></tr>
    <tr><td class="paramname">whitespace</td><td>Set of characters to be considered as whitespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent to the input one, with leading and trailing whitespace removed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="simple__options__file__parser_8hpp_source.html">simple_options_file_parser.hpp</a></li>
<li>src/<a class="el" href="simple__options__file__parser_8cpp.html">simple_options_file_parser.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<table width = "100%" border="0">
 <tr valign="middle">
   <td>
     <font size="-1"><i>simple_options_file_parser (version 1.0.01). Documentation generated on Tue Dec 3 2024 13:48:13 </i></font>
   </td>
   <td  style="padding-right: 10px;">
     <div align="right">
       <img src="HTML_icon.png">
     </div>
   </td>
  </tr>
</table>
</BODY>
</HTML>
